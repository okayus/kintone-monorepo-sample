# 新規カスタマイズ開発ガイド（JavaScript + モジュール）

## 概要
既存のJavaScriptファイルはそのまま維持しつつ、新規カスタマイズはモジュール形式のJavaScriptで開発します。Viteでビルドし、kintone-commonの共通モジュールを利用できます。

## 開発フロー

### 1. 新規カスタマイズプロジェクトの作成

```bash
# 例：アプリID 2222の新規カスタマイズを作成
mkdir -p kintone/2222/new-customization
cd kintone/2222/new-customization
```

### 2. package.jsonの作成

```json
{
  "name": "kintone-app-2222-new-customization",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite build --watch",
    "build": "vite build",
    "test": "vitest",
    "test:ui": "vitest --ui"
  },
  "dependencies": {
    "@kintone-sample/common": "file:../../kintone-common",
    "@kintone/rest-api-client": "^5.0.0"
  },
  "devDependencies": {
    "@vitest/ui": "^1.0.0",
    "jsdom": "^23.0.0",
    "vite": "^5.0.0",
    "vitest": "^1.0.0"
  }
}
```

### 3. vite.config.jsの作成

```javascript
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  build: {
    lib: {
      entry: resolve(__dirname, 'src/index.js'),
      name: 'KintoneApp2222NewCustomization',
      fileName: 'bundle',
      formats: ['iife']
    },
    rollupOptions: {
      external: [],
      output: {
        extend: true,
        globals: {}
      }
    },
    outDir: 'dist',
    emptyOutDir: true
  },
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './test/setup.js'
  }
});
```

### 4. 依存関係のインストール

```bash
# プロジェクトルートで
npm install

# kintone-commonをビルド
cd kintone-common
npm run build
```

### 5. コード作成例

#### src/index.js（エントリーポイント）
```javascript
import { KintoneSdk, KintoneUtil } from '@kintone-sample/common';
import { myCustomFunction } from './modules/myModule.js';

(() => {
  'use strict';

  kintone.events.on('app.record.detail.show', (event) => {
    // KintoneUtilを使用
    const title = KintoneUtil.getFieldValue(event.record, 'タイトル');
    console.log('タイトル:', title);
    
    // 独自モジュールの使用
    myCustomFunction(event.record);
    
    return event;
  });
})();
```

#### src/modules/myModule.js（モジュール例）
```javascript
export function myCustomFunction(record) {
  // モジュール化されたロジック
  console.log('カスタム関数が実行されました');
}
```

### 6. ユニットテストの作成

#### test/modules/myModule.test.js
```javascript
import { describe, it, expect } from 'vitest';
import { myCustomFunction } from '../../src/modules/myModule.js';

describe('myModule', () => {
  it('カスタム関数が正しく動作する', () => {
    const mockRecord = { 
      'タイトル': { value: 'テスト' }
    };
    
    // テストの実行と検証
    expect(() => myCustomFunction(mockRecord)).not.toThrow();
  });
});
```

### 7. ビルドとデプロイ

```bash
# 開発時（ウォッチモード）
npm run dev

# 本番ビルド
npm run build

# テスト実行
npm test
```

ビルド後、`dist/bundle.iife.js`がkintoneにアップロードするファイルになります。

## 既存JSとの共存

### kintoneへのアップロード順序
1. kintone-common.umd.js（共通ライブラリ）
2. 既存のJSファイル（例：2222/postSlack.js）
3. 新規ビルドファイル（例：bundle.iife.js）

### 既存JSからkintone-commonを使う場合
```javascript
// 既存のJS内で
const { KintoneSdk } = window.KintoneCommon;
```

## メリット

1. **段階的な移行**: 既存コードを保持しながら新規開発をモダンに
2. **モジュール管理**: importによる依存関係の明確化
3. **テスト可能**: Vitestによる単体テストの実行
4. **共通化**: kintone-commonの再利用
5. **型定義の恩恵**: エディタの補完機能を活用（将来的にTypeScript移行も容易）

## 注意事項

- 新規カスタマイズはすべてこの形式で開発
- 既存JSファイルの改修は最小限に
- ビルド成果物のみをkintoneにアップロード（srcフォルダは不要）
- node_modulesはgitignoreに追加